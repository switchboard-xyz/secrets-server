use crate::*;

use poem::{
    error::ResponseError,
    handler,
    http::StatusCode,
    middleware::Middleware,
    web::{Data, Json},
    Request, Response, ResponseBuilder, Route,
};
use regex::Regex;
use ring::{error, signature, signature::VerificationAlgorithm};
use sha2::{Digest, Sha256};
use std::error::Error;
use std::sync::Arc;

/// A possible error value occurred in the `SignatureVerification` middleware.
#[derive(Debug, thiserror::Error, Eq, PartialEq)]
pub enum SignatureVerificationMiddlewareError {
    /// Headers not allowed
    #[error("signature verification failed")]
    SignatureVerificationFailed,
}
impl ResponseError for SignatureVerificationMiddlewareError {
    fn status(&self) -> StatusCode {
        StatusCode::BAD_REQUEST
    }
}

fn extract_user_pubkey(uri: &str) -> Result<String, poem::Error> {
    let re = Regex::new(r"/user/([^/]+)").map_err(InternalServerError)?;

    if let Some(caps) = re.captures(uri) {
        if let Some(user_pubkey) = caps.get(1) {
            return Ok(user_pubkey.as_str().to_string());
        }
    }

    Err(poem::error::NotFoundError.into())
}

pub struct SignatureVerificationMiddleware;

impl<E: Endpoint> Middleware<E> for SignatureVerificationMiddleware {
    type Output = SignatureVerificationMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        SignatureVerificationMiddlewareImpl { ep }
    }
}

/// Signature data, (pubkey, signature)
pub struct SignatureAuth {
    pub pubkey: String,
    pub signature: String,
}
impl SignatureAuth {
    pub fn verify(&self) -> Result<(), Box<dyn Error>> {
        Ok(())
    }
}

/// The new endpoint type generated by the TokenMiddleware.
pub struct SignatureVerificationMiddlewareImpl<E> {
    ep: E,
}

#[poem::async_trait]
impl<E: Endpoint> Endpoint for SignatureVerificationMiddlewareImpl<E> {
    type Output = E::Output;

    // Validate the signature if the /users/:user_pubkey is found in the path
    async fn call(&self, mut req: Request) -> Result<Self::Output> {
        // Extract the user's pubkey from the request path if it starts with /user/:user_pubkey
        if let Ok(user_pubkey) = extract_user_pubkey(req.uri().path()) {
            // Extract the signature from the X-Signed-Header header
            if let Some(value) = req
                .headers()
                .get("X-Signed-Header")
                .and_then(|value| value.to_str().ok())
            {
                // TODO: validate the signature here
                // TODO: validate the signature here
                // let mut body = req.body().clone();
                // let mut bytes = vec![];
                // body.read_to_end(&mut bytes).await?;
                // let payload = String::from_utf8(bytes).unwrap();
                // let v: Value = serde_json::from_str(&payload).unwrap();
                // if let Some(pubkey) = v.get("pubkey") {
                //     println!("pubkey: {:?}", pubkey);
                // }
                // if let Some(ciphersuite) = v.get("ciphersuite") {
                //     println!("ciphersuite: {:?}", ciphersuite);
                // }
            } else {
                return Err(
                    SignatureVerificationMiddlewareError::SignatureVerificationFailed.into(),
                );
            }
        }

        // call the next endpoint.
        self.ep.call(req).await
    }
}

// #[poem::async_trait]
// impl poem::Middleware for SignatureVerificationMiddlewareImpl<E> {
//     async fn handle(&self, req: &Request, next: poem::Next<'_>) -> poem::Result<Response> {
//         let mut body = req.body().clone();
//         let mut bytes = vec![];
//         body.read_to_end(&mut bytes).await?;
//         println!("Payload in binary: {:?}", bytes);
//         next.run(req).await
//     }
// }

#[cfg(test)]
mod tests {
    use super::*;

    use poem::{handler, http::StatusCode, middleware::Middleware, Request, Route, Server};
    use rand::rngs::OsRng;
    use tokio::task::spawn;

    #[tokio::test]
    async fn test_signature_verification() {
        // Create a server with the SignatureVerification middleware
        let app = Route::new()
            .at("/user/:user_pubkey", handler(|_| async { "OK" }))
            .with(SignatureVerification);

        // Create a new RSA key pair
        let rng = rand::SystemRandom::new();
        let key_pair = signature::RsaKeyPair::generate_pkcs1(&mut OsRng, 2048).unwrap();
        let pubkey_bytes = key_pair.public_key().as_ref();

        // Create a signature
        let message = b"test message";
        let signature = key_pair
            .sign(&signature::RSA_PKCS1_SHA256, &rng, message)
            .unwrap();

        // Create a server task
        let server = spawn(async { Server::bind("127.0.0.1:0").await.unwrap().run(app).await });

        // Create a client to test the server
        let client = reqwest::Client::new();

        // Construct the URL
        let addr = server.get_ref().local_addr();
        let url = format!(
            "http://{}:{}/user/{}",
            addr.ip(),
            addr.port(),
            hex::encode(pubkey_bytes)
        );

        // Send a GET request with the signature header
        let res = client
            .get(&url)
            .header("X-Signed-Header", hex::encode(signature.as_ref()))
            .send()
            .await
            .unwrap();

        // Assert that the status is OK (200)
        assert_eq!(res.status(), StatusCode::OK);

        // Retrieve the response text
        let text = res.text().await.unwrap();

        // Assert that the response is "OK"
        assert_eq!(text, "OK");

        // Clean up the server task
        server.abort();
    }
}

fn verify_payload(
    payload: Vec<u8>,
    signature: &str,
    pubkey: &str,
    ciphersuite: &str,
) -> Result<bool, Box<dyn Error>> {
    let mut hasher = Sha256::new();
    hasher.update(payload);
    let result = hasher.finalize();

    let signature_bytes = base64::decode(signature)?;
    let pubkey_bytes = base64::decode(pubkey)?;

    //note: will return error on both invalid AND incorrect signatures
    match ciphersuite {
        "secp256k1" => {
            let public_key = untrusted::Input::from(&pubkey_bytes);
            let msg = untrusted::Input::from(&result);
            let sig = untrusted::Input::from(&signature_bytes);
            let alg = &signature::ECDSA_P256_SHA256_FIXED;
            alg.verify(public_key, msg, sig).map_err(|_| {
                std::io::Error::new(std::io::ErrorKind::Other, "Verification failed")
            })?;
        }
        "ed25519" => {
            let public_key = untrusted::Input::from(&pubkey_bytes);
            let msg = untrusted::Input::from(&result);
            let sig = untrusted::Input::from(&signature_bytes);
            let alg = &signature::ED25519;
            alg.verify(public_key, msg, sig).map_err(|_| {
                // Convert the Unspecified to a standard IO error.
                std::io::Error::new(std::io::ErrorKind::Other, "Verification failed")
            })?;
        }
        _ => return Err("Unsupported ciphersuite".into()),
    }

    Ok(true)
}

// let middleware = FnMiddleware::new(|req: Request, next: Endpoint| async move {
//     let mut hasher = Sha256::new();
//     let body = req.body().await.unwrap();
//     hasher.update(body);
//     let result = hasher.finalize();
//     println!("SHA256 Hash: {:?}", result);
//     next.call(req).await
// });
